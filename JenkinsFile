def sendEmail(subject,content)
{
		emailext (body: content,
			mimeType: 'text/html',
			subject: "[Jenkins] Hub ${subject}",
			to: "${BUILD_NOTIFICATION_RECIPIENTS}")
			
}

pipeline 
{
	parameters 
	{
		string(name: "authenticationDomain" , defaultValue : 'app.geeks.ltd')				
		string(name: "ecrAddress", defaultValue: '669486994886.dkr.ecr.eu-west-1.amazonaws.com')		
		string(name: "region", defaultValue: 'eu-west-1')						
		string(name: "k8sSSHServer" , defaultValue : 'https://api.app.geeks.ltd') <----------																			
		string(name: "privateRepositoryAddress" , defaultValue : 'http://nuget.geeksms.uat.co/nuget')				
		booleanParam(name: "Rebuild" , defaultValue : false)
	}
    environment 
    {        
        IMAGE = 'geeksms-hub'		
		REGION_NAME = "${params.region}"
		ECR_URL = "https://${params.ecrAddress}"
		ECR_CRED = credentials('ECRCRED')
		BUILD_VERSION="v_${BUILD_NUMBER}"
		ECR_IMAGE_URL = "${params.ecrAddress}/${IMAGE}:${BUILD_VERSION}"        		
        AWS_CREDENTIALS_ID = 'JenkinsECRAWSCredentials'
		GIT_REPOSITORY = 'https://gitlab.com/Geeks.Microservices/accesshub.git'
		GIT_CREDENTIALS_ID = '1ef3615c-8221-4d33-af6d-91b203d60c75'
		BUILD_VERION_NUMBER = '0'				
		K8S_SSH_SERVER = "${params.k8sSSHServer}"
		K8S_DEPLOYMENT_TEMPLATE = ".\\DevOps\\Kubernetes\\Deployment.yaml"		
		K8S_LATEST_CONFIG_FILE = "DevOps/Kubernetes/Deployment.yaml"						
		PRIVATE_REPOSITORY_ADDRESS = "${params.privateRepositoryAddress}"
		PRIVATE_REPOSITORY_ADDRESS_NAME = "GeeksMS"
		AUTHENTICATION_DOMAIN = "${params.authenticationDomain}"
		HUB_SERVICE_URL = "https://hub.app.geeks.ltd"
		BUILD_NOTIFICATION_RECIPIENTS = "paymon@geeks.ltd.uk"
    }
    agent any
    stages{    
			
			stage('Delete the old version') 
            {
				when { expression { params.Rebuild } }
                steps { script { deleteDir() } } 
            }
			
			stage('Add the private repository') 
            {
                steps
                {
                    script
                        {						
							sh ''' 
								if [[ ! $(nuget sources) = *"${PRIVATE_REPOSITORY_ADDRESS_NAME}"* ]]; then 
									nuget sources Add -Name "${PRIVATE_REPOSITORY_ADDRESS_NAME}" -Source ${PRIVATE_REPOSITORY_ADDRESS} 
									echo "Installed the private repository"
								else
									echo "The private repository already exists"
								fi									
							   '''
                        }
                }
            }
				
            stage('Clone sources') 
            {
                steps
                {
                    script
                        {						
							git credentialsId: GIT_CREDENTIALS_ID, url: GIT_REPOSITORY
                        }
                }				
            }			
			
			stage('Update settings') 
            {
                steps
                {
                    script
                        {			
							echo "Update the application version"
							bat ''' replace-in-file "./Website/appsettings.json" -set "%%APP_VERSION%%" %BUILD_NUMBER% '''													
                        }										
                }
            }

			stage('Update require js baseUrl') 
            {
                steps
                {
					script
						{	
							echo "Update require js baseUrl"
							bat ''' replace-in-file "./Website/wwwroot/scripts/references.js" -set "http://localhost:9011" "%HUB_SERVICE_URL%" '''							
						}
                }
            }				
			
			stage('Remove GCop')
            {
                steps 
                {
                    script 
                        {
							bat 'nuget sources'
                            bat 'for /r %%i in (.\\*.csproj) do (type %%i | find /v "GCop" > %%i_temp && move /y %%i_temp %%i)'
                        }
                }
            }
			
			stage('Build')
            {
                steps 
                {
                    script { bat 'call ./Build.bat -publish' } 
                }
            }      
			
			stage('Stashing artefacts')
			{
				steps
				{
					dir(WORKSPACE)
					{
						stash includes: 'Dockerfile', name: 'Dockerfile'
						stash includes: 'publish/**/*', name: 'Website'
					}
				}
			}
			
			stage('Clear the workspace (on linux)')
			{
				steps 
                {
                    node('LinuxDocker')
                    {                        
                        script 
                            {   
								cleanWs();
                            }
                    }
                }
			}
			
            stage('Unstash artefacts (on linux)')
            {
				steps
				{
					node('LinuxDocker')
                    { 
						unstash 'Dockerfile'
						unstash 'Website'
					}
				}
			}			
            stage('Docker build (on linux)')
            {
				steps 
                {
                    node('LinuxDocker')
                    {                        
                        script 
                            {   
								sh "docker build -t ${IMAGE} ."
                            }
                    }
                }
            }
    
            stage('Push to ECR (on linux)')
            {
                steps 
                {
					node('LinuxDocker')
					{        
						script 
						{
							withAWS(credentials:AWS_CREDENTIALS_ID)
							{
								// login to ECR - for now it seems that that the ECR Jenkins plugin is not performing the login as expected. I hope it will in the future.
								sh("eval \$(aws ecr get-login --no-include-email --region eu-west-1 | sed 's|https://||')")
						
								docker.withRegistry(ECR_URL, ECR_CRED) 
								{
									docker.image(IMAGE).push(BUILD_VERSION)
								}						
							}
						}
					}
                }
            }

			stage('Update the K8s deployment file')
            {
                steps 
                {        
                    script 
                    {
						bat ''' replace-in-file %K8S_DEPLOYMENT_TEMPLATE% -set "%%DOCKER_IMAGE%%" %ECR_IMAGE_URL% -set "%%BUILD_VERSION%%" %BUILD_VERSION% '''						
                    }
                }
            }				

			stage('Deploy to cluster')
            {
                steps 
                {
        
                    script 
                    {
					
						withCredentials([string(credentialsId: 'K8sCertificateAuthorityData', variable: 'K8S_CERTIFICATE_AUTHORITY_DATA'), string(credentialsId: 'K8sClientCertificateData', variable: 'K8s_CLIENT_AUTHORITY_DATA'), string(credentialsId: 'K8sClientKeyData', variable: 'K8s_CERTIFICATE_KEY_DATA')]) 
						{
						
						kubernetesDeploy(
							credentialsType: 'Text',
							textCredentials: 
							[
								serverUrl: K8S_SSH_SERVER,
								certificateAuthorityData: K8s_CERTIFICATE_AUTHORITY_DATA,
								clientCertificateData: K8s_CLIENT_AUTHORITY_DATA,
								clientKeyData: K8s_CERTIFICATE_KEY_DATA,
							],
							configs: K8S_LATEST_CONFIG_FILE,
							enableConfigSubstitution: true,
						)
						}
                    }
                }
            }				

        }
        
     post
    {
		failure
		{
			script 
			{
				sendEmail('(Failed)', 'Failed to deploy HUB to production')
			}
		}
		success
		{
			script 
			{
				sendEmail('(Succeeded)','Deployed HUB to production')
			}
		}
        always
        {
			node('LinuxDocker')
			{ 
				// make sure that the Docker image is removed
				sh '''docker rmi $IMAGE | true'''
			}
        }
    }
}

